\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
% Redefine labelwidth for lists; otherwise, the enumerate package will cause
% markers to extend beyond the left margin.
\makeatletter\AtBeginDocument{%
  \renewcommand{\@listi}
    {\setlength{\labelwidth}{4em}}
}\makeatother
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage[breaklinks=true,unicode=true]{hyperref}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setcounter{secnumdepth}{0}

\usepackage[russian]{babel}
\usepackage[T1]{fontenc}
\usepackage{amssymb,amsmath,indentfirst}
\usepackage{caption}
\usepackage{color}

\begin{document}

\tableofcontents

\section{Вступ}

У вік технологічних новацій доволі часто рівень користування цими
технологіями доволі слабкий у порівнянні з реальними можливостями.
Розвиток комп'ютерної техніки та її широке розповсюдження серед
практично всіх верств населення, розповсюдження мережі інтернет
сприяють поширенню технологій дистанційного доступу до актуальної
інформації, і річ йде про одне з саме таких нововведень.

Наразі все більшої актуальності набуває дистанційне навчання, за
якого студент практично не залежить від реальної присутності в
інституті, що може знаходитись за сотні кілометрів від реального
перебування студента. Часто це буває необхідним при неспроможності
студента бути безпосередньо присутнім на зайняттях, а описана нижче
система дає змогу успішно навчатись і показувати свої знання та
здобувати свої оцінки при несприятливих для відвідування
обставинах. Дана система дозволяє виконувати завдання, відсилати
протоколи по виконаній роботі та, власне, опрацьовувати новий
матеріал через мережу інтернет.

На початок 2011 року кількість інтернет користувачів перевищило
третину населення України (загалом це молодь), а отже можна
говорити про хороше підґрунтя для поширення даного способу
тестування знань.

\begin{figure}[htb]
\centering
\includegraphics{1_vstup_network.png}
\caption{Network}
\end{figure}

Загалом, схема користування даною систему оцінки знань може бути
зведена до досить простих кроків, як-то: * Отримання свого логіну
та паролю від адміністратора системи

\begin{itemize}
\item
  Вхід на сайт як зареєстрований користувач і перегляд власних
  індивідуальних завдань, що з'являються і доступі виключно того дня,
  на який призначено заняття.

\item
  Умова індивідуальна - студент вирішує поставлену перед ним задачу у
  індивідуальному порядку, показує навики володіння матеріалом.

\item
  Написання тексту відповіді у присутньому у системі редакторі –
  емуляції середовища для моделювання обробки команд процесором
  MIPS.

\item
  Також є можливість перевірити виконане завдання на коректність
  перед тим, як відсилати його на перевірку.

\item
  Оформлення протоколу відбувається на стороні студента, потім кожна
  робота, виконана у системі має бути підтверджена завіреним вчителем
  протоколом.

\item
  У протоколі можуть бути викладені коментарі щодо виконаного
  завдання. Обов'язковим являється виконання технічних умов щодо
  вмісту протоколу завдання, як-то описання призначення регістрів,
  які використовувались, та машинний код команди, який генерується,
  власне, програмним середовищем.

\end{itemize}
Унікальний момент для викладача – система звільняє і його від
рутинної перевірки завдань, адже у системі є вбудована система
тестів, що дозволяє визначити коректність виконання студентом
завдання.

\begin{figure}[htb]
\centering
\includegraphics{1_vstup_workflow.png}
\caption{Workflow}
\end{figure}

Рис. 1

На Рис. 1 представлена схема роботи системи дистанційної перевірки
знань. Даний ресурс відповідає ідеї спрощення проведення
лабораторних робіт по дисципліні «Архітектура операційних систем» і
має на меті реалізувати систему дистанційного виконання студентами
завдань, для яких присутність студента потребувалась раніше
виключно через неможливість виконання завдання іншим способом. Це
значне спрощення процесу навчання та вельми корисне нововведення
технологій у навчальних процес.

\section{Робота з системою дистанційного оцінювання.}

Отже ми побачили переваги і можливості, що надає нам дана система
контролю і оцінювання навчального процесу. Тепер давайте детальніше
ознайомимося з процесом роботи з даною системою.

\subsubsection{Вхід в систему.}

Для того щоб розпочати роботу з індивідуальним лабораторним
завданням необхідно ввійти в систему, тобто авторизуватися на сайті
вказавши свою групу, прізвище та ім'я (Рис. 2).

\begin{figure}[htb]
\centering
\includegraphics{2_guide_login1.png}
\caption{Login \#1}
\end{figure}

Рис. 2 «форма входу»

\begin{figure}[htb]
\centering
\includegraphics{2_guide_login2.png}
\caption{Login \#2}
\end{figure}

Рис. 2.1 Зверніть увагу на те, що під час введення групи необхідно
ввести лише її номер, а система автоматично підставить все інше,
тобто студент групи КА--85 має ввести FIXME

\begin{figure}[htb]
\centering
\includegraphics{2_guide_login3.png}
\caption{Login \#3}
\end{figure}

Рис 2.2 Необхідно також ввести повне прізвище та ім'я

Після того як у відповідні поля буде введено інформацію
відобразиться індивідуальна сторінка студента з станом про
виконання лабораторних робіт на даний момент (Рис 3). А саме:

\begin{figure}[htb]
\centering
\includegraphics{2_guide_course.png}
\caption{Index}
\end{figure}

Рис. 3 «вигляд основної робочої сторінки»

\begin{itemize}
\item
  Opens дата відкриття завдання конкретної лабораторної роботи
\item
  Task Type Тип виконуваної роботи
\item
  Task Name назва лабораторної роботи
\item
  Status стан цієї лабораторної роботи на даний момент(в процесі
  перевірки, не зроблено, зроблено з відповідною оцінкою);
\item
  Action FIXME
\item
  Score максимальна оцінка за дану роботу і отримана студентом оцінка
  з урахування всіх бонусів та відрахувань балів за несвоєчасність
  виконання
\item
  Pending Показує, чи є якісь заборгованості по завданням даної
  роботи
\item
  Open FIXME
\item
  Course Файли в цьому розділі показують скільки і які тести має
  пройти код лабораторної роботи. Останній файл у розділі показує
  приклад вихідного коду.
\end{itemize}
\subsubsection{Виконання робіт.}

Отже після входу в систему починаємо роботу з нею. Для виконання
певної лабораторної роботи необхідно відкрити середовище для роботи
з кодом на асемблері MIPS. Для цього відкриваємо роботу кнопкою
Open навпроти неї. Опиняємося на наступній сторінці (Рис 4). (щоб
отримати повну інформацію в комбобоксі, що виділений червоним
обираємо значення Any/Student):

\begin{figure}[htb]
\centering
\includegraphics{2_guide_listing.png}
\caption{Index}
\end{figure}

Рис. 4

Вона надає нам наступні можливості: * Відправити звіт по
відповідній лабораторній роботі – UL * Створити програмний код на
асемблері MIPS – E

Обравши ``E'' система відкриває середовище для розробки програмного
коду, а також індивідуальне завдання даної роботи (Рис. 5).

\begin{figure}[htb]
\centering
\includegraphics{2_guide_editor.png}
\caption{Index}
\end{figure}

Рис. 5

Наше завдання полягає у створенні програми, що виконуватиме
поставлену задачу. \textbf{Наприклад маємо завдання}:

\begin{verbatim}
Виділити нульовий біт регістру $a0 і помістити результат в $v0.
\end{verbatim}
Трішки подумавши ми розуміємо, зо код програми має виглядати
приблизно таким чином:

\begin{verbatim}
andi $v0,$a0,1
\end{verbatim}
Далі, як і в будь-якому іншому середовищі розробки програм, ми
маємо скомпілювати отриманий код і перевірити на наявність помилок.
Для цього використовуємо \textbf{Verify}.

\begin{figure}[htb]
\centering
\includegraphics{2_guide_compile.png}
\caption{Index}
\end{figure}

Перевірка отриманого коду здійснюється по кільком критеріям і в
кілька етапів. Код вважається правильним якщо він пройшов всі
тести. Цілком природнім є бажання розробника виконати покрокове
тестування програми для виявлення помилок. Для цього обираємо
\textbf{Assemble\textgreater{} Step\textgreater{}} і покроково
виконуємо кожну оперцію. Або ж
\textbf{Assemble\textgreater{} Run\textgreater{}} (Рис. 6) -
виконуємо всю програму зразу. Після цього отримуємо результати
тестування програми: кількість пройдених чи не пройдених програмою
тестів.

\begin{figure}[htb]
\centering
\includegraphics{2_guide_stepmode.png}
\caption{Index}
\end{figure}

Рис. 6 «середовище відладки коду»

При виникненні помилок чи не проходженні програмою перевірок
звичано можна продовжувати відладку коду зручними для користувача
способами. Після того як всі тести програмою пройдено необхідно
відправити програмний код. Це виконується кнопкою \textbf{Submit}.

\subsubsection{Оформлення протоколу.}

Залишається заключний етап виконання лабораторної роботи –
оформлення звіту. В звіті мають бути: * Назва лабораторної роботи *
Завдання * Опис операндів (призначення кожного регістру в коді
програи) * Текст програми на асемблера MIPS * Машинний код
операцій

Система сама генерує машинний код кожної операції програми, тому
його не треба прописувати вручну, а можна скопіювати з вкладки
Run\textgreater{} середовища розробки програми.

Для того, щоб звіт був перевірений викладачем його слід надіслати.
Це можна зробити наступним чином (Рис. 7): Обравши потрібну
лабораторну роботу натискаємо UL. Після чого завантажуємо зроблений
нами звіт на сервер. (Зверніть увагу, що завантажувані файли мають
бути у форматі rtf).

\begin{figure}[htb]
\centering
\includegraphics{2_guide_upload.png}
\caption{Index}
\end{figure}

Рис. 7 «форма завантаження протоколу»

\subsubsection{Бонуси та штрафи.}

Звичайно ж в данный системі існують деякі правила нарахування
заохочувальних балів старанним студентам.

виконання лабораторної роботи прямо в аудиторії, під час
проходження практичного заняття або до 18.00 поточного дня +25\%
від максимального балу за дану лабораторну роботу

Виконання лабораторної роботи під час практичного заняття, але з
ip-адреси, що знаходиться поза межами КПІ Бонусні бали не
нараховуються.

\section{Комп'ютерний практикум №1.}

\textbf{Тема}: Арифметичні операції. \textbf{Мета роботи}:
Ознайомитися з базовими інструкціями для виконання арифметичних
операцій.

\subsection{Теоретичні відомості.}

Даний запис ассемблерної команди MIPS:

\begin{verbatim}
add a, b, c
\end{verbatim}
надає комп'ютеру інструкцію додати 2 зміні a та b і записати
результат в змінну с. Ця нотація є жорстко визначеною в кожній
арифметичній інструкції MIPS, так як вона виконує лише одну
операцію і завжди повинна мати рівно три операнда.

Наприклад, припустимо, що ми хочемо записати суму чотирьох змінних
b, c, d та e в змінну а. Наступна послідовність команд додає чотири
змінні:

\begin{verbatim}
add a, b, c #the sum of b and c is placed in a.
add a, a, c #the sum of b, c and d is now in a.
add a, a, e #the sum of b, c, d and e is now in a.
\end{verbatim}
Отже потрібно три інструкції, щоб додати чотири змінні.

Слова праворуч від символу шарп (\#) - коментарі, їх комп'ютер
ігнорує. Зауважимо, що на відміну від інших мов програмування кожен
рядок цієї мови може містити не більше однієї команди. Інша
відмінність від С, що коментарі завжди закінчуются в кінці рядка.

Звичайне число операндів для операції як додавання - три: два
числа, що додаються, і змінна, для запису результату. Вимога до
кожної команди мати рівно три операнди свідчить про ідею спрощення
апаратного забезпечення: обладнання для змінної кількості операндів
складніше ніж для фіксованої.

Тепер ми можемо показати, в двох прикладах, що показують зв'язок
між мовами високого рівня і більш примітивними інструкціями:

\subsubsection{Перетворення двох команд на мові С в MIPS:}

Цей фрагмент коду на С містить 5 операндів a,b,c,d,e:

\begin{verbatim}
a=b+c;
d=a-e;
\end{verbatim}
Трансляцію із С в асемблер MIPS здійснює компілятор. Отримуємо
наступний код. Інструкції MIPS використовують 2 змінні джерела і
записують результат в один операнд - приймач. Тобто дві попередні
інструкції прямо перетворяться в дві інструкції на асемблері MIPS

\begin{verbatim}
add a, b, c
sub d, a, e
\end{verbatim}
\subsubsection{Перетворення складних інструкції мови С в MIPS.}

Якась складна інструкція містить п'ять змінних f, q, h, i, та j:

\begin{verbatim}
f=(g+h)-(i+j);
\end{verbatim}
Отже, що ми можемо отримати після компіляції? Компілятор має
розбити команду на декілька асемблерних інструкцій, так щоб тільки
одна операція припадала на одну інструкцію. Перша інструкція
асемблера MIPS рахує суму g та h. Та ми маємо десь зберегти
результат, тому компілятор створює тимчасову змінну t0.

\begin{verbatim}
add t0, g, h # temporary variable t0 contains g + h
\end{verbatim}
Незважаючи на те, що наступна операція - віднімання, ми маємо
порахувати суму i + j перед тим як віднімати. отже наступна
інструкція записує суму i + j в тимчасову змінну t1:

\begin{verbatim}
add t1, i, j # temporary variable t1 contains i + j
\end{verbatim}
І нарешті віднімаємо від першої суми другу інструкцією віднімання,
поміщаємо різницю в змінну f:

\begin{verbatim}
sub f, t0, t1 # f gets t0-t1 which is (g+h)-(i+j)
\end{verbatim}
\subsubsection{Константи або безпосередні операнди.}

Програма багато разів використовує константи операціях, наприклад:
інкремент індексу для переходу на наступний елемент масиву.
Насправді більше половини арифметичних інструкцій MIPS мають як
операнд константу під час запуску еталонної тестової програми
SPEC2006.

Використовуючи лише інструкції, які ми розглядали раніше, ми
повинні були б завантижувати константу з пам'яті, щоб її
використовувати(Константи були б розміщені в пам'яті, коли програма
завантажувалась). Альтернатива, яка дозволяє уникнути навантаження
інструкції - запропонувати версії арифметичних команд, в яких один
з операндів - константа. Ця швидка інструкція add з одним
константним операндом називається безпосереднім додаванням
(immediate add) або addi. Щоб додати до 4 регістр \$s3 ми просто
пишемо:

\begin{verbatim}
addi $s3, $s3, 4 # $s3= $s3+ 4
\end{verbatim}
Константні операнди зустрічаються часто, і включення константних
операндів всередину арифметичних інструкцій зробило їх набагато
швидшими і енергозберігаючими, в порівнянні з тим, якби константи
завантажувалися з пам'яті.

У константи нуль інша задача - спрощувати набір команд, пропонуючи
корисні зміни. Наприклад, операція mov це та ж сама операція add, в
якій просто один операнд 0. Отже, в MIPS призначення регістра
\$zero бути машинним нулем. (Не важко здогадатися, що його номер
0).

\subsection{Хід роботи}

Переглянути текст варіанту завдання та приклади вхідних та вихідних
значень регістрів та пам'яті. У випадку, якщо текстове завдання
дозволяє декілька інтерпретацій - перевірте приклади значень для
уточнення.

Реалізувати завдання на рівні інструкцій MIPS. Якщо сформулювати
алгоритм вирішення задачі не рівні інструкцій не вдається, можна
спочатку розробити його на будь-якій мові програмування високого
рівня.

Перевірити, що вихідний код компілюється без помилок и проходить
всі тести, які надає система. У випадку, коли деякі тести
завершуються помилкою, краще провести аналіз детального
повідомлення про помилку, яке повертає система при виконанні цього
тесту, ніж аналізувати повідомлення при виконанні всіх тестів у
пакетному режимі.

Відіслати код розв'язку на сервер, перевірити результати виконання
коду на сервері. Оформити протокол виконання комп'ютерного
практикуму: скопіювати вихідний код розв'язку та машинний код
розв'язку у протокол.

\subsection{Запитання для перевірки:}

\begin{itemize}
\item
  Скільки команд міститься в одній інструкції?
\item
  Які регістри використовуються для збереження тимчасового
  результату?
\item
  В чому полягають переваги команд, в яких один із операндів –
  константа? Наведіть приклади таких команд.
\item
  Чи можна замінити команду аналогічною їй за результатом іншою
  командою?
\end{itemize}
\subsection{Варіанти завдань:}

\begin{enumerate}[1.]
\item
  Збільшити на 2. Збільшити вміст регістру \$a0 на 2.
\item
  Зменшити на 2. Зменшити вміст регістра \$a0 на 2.
\item
  Сума. Дадати вміст регістрів \$a0 та \$a1 і записати результат в
  \$v0.
\item
  Віднімання. Відняти вміст регістру \$a1 від вмісту регістра \$a0 і
  записати результат в \$v0.
\item
  Множення. Перемножити вміст регістрів \$a0 і \$a1 та записати
  результат в \$v0.
\item
  Ділення. Розділити вміст регістру \$a0 на вміст регістру \$a1 і
  записати цілу частину до \$v0.

\item
  Збільшити на 2. Збільшити вміст регістру \$a0 на 2.
\item
  Приклад 1: * \$a0:65:67
\item
  Приклад 2: * \$a0:9:11
\item
  Приклад 3: * \$a0:23:25
\item
  Зменшити на 2.*Зменшити вміст регістра \$a0 на 2.
\item
  Приклад 1:
  \begin{itemize}
  \item
    \$a0:65:63
  \end{itemize}
\item
  Приклад 2:
  \begin{itemize}
  \item
    \$a0:9:7
  \end{itemize}
\item
  Приклад 3:
  \begin{itemize}
  \item
    \$a0:23:21
  \end{itemize}
\item
  \emph{Сума.}Дадати вміст регістрів \$a0 та \$a1 і записати
  результат в \$v0.
  \begin{itemize}
  \item
    Приклад 1:
  \item
    \$a0:65:65
  \item
    \$a1:3:3
  \item
    \$v0::68
  \item
    Приклад 2:
  \item
    \$a0:9:9
  \item
    \$a1:17:17
  \item
    \$v0::26
  \item
    Приклад 3:
  \item
    \$a0:23:23
  \item
    \$a1:5:5
  \item
    \$v0::28
  \end{itemize}
\item
  \emph{Віднімання.}Відняти вміст регістру \$a1 від вмісту регістра
  \$a0 і записати результат в \$v0.
  \begin{itemize}
  \item
    Приклад 1:
  \item
    \$a0:65:65
  \item
    \$a1:3:3
  \item
    \$v0::62
  \item
    Приклад 2:
  \item
    \$a0:9:9
  \item
    \$a1:17:17
  \item
    \$v0::--8
  \item
    Приклад 3:
  \item
    \$a0:23:23
  \item
    \$a1:5:5
  \item
    \$v0::18
  \end{itemize}
\item
  \emph{Множення.}Перемножити вміст регістрів \$a0 і \$a1 та записати
  результат в \$v0.
  \begin{itemize}
  \item
    Приклад 1:
  \item
    \$a0:13:13
  \item
    \$a1:3:3
  \item
    \$v0::39
  \item
    Приклад 2:
  \item
    \$a0:11:11
  \item
    \$a1:12:12
  \item
    \$v0::132
  \item
    Приклад 3:
  \item
    \$a0:25:25
  \item
    \$a1:4:4
  \item
    \$v0::100
  \end{itemize}
\item
  \emph{Ділення.}Розділити вміст регістру \$a0 на вміст регістру \$a1
  і записати цілу частину до \$v0.
  \begin{itemize}
  \item
    Приклад 1:
  \item
    \$a0:12:12
  \item
    \$a1:3:3
  \item
    \$v0::4
  \item
    Приклад 2:
  \item
    \$a0:117:117
  \item
    \$a1:7:7
  \item
    \$v0::16
  \item
    Приклад 3:
  \item
    \$a0:43:43
  \item
    \$a1:4:4
  \item
    \$v0::10
  \end{itemize}
\end{enumerate}
\section{Комп'ютерний практикум №2}

\textbf{тема} Робота з пам'яттю \textbf{Мета роботи}: Ознайомитися
з базовими інструкціями для роботи з пам'яттю.

\subsection{Теоретичні відомості.}

\begin{figure}[htb]
\centering
\includegraphics{4_memory_words.png}
\caption{Index}
\end{figure}

Операнди пам'яті.

Мови програмування містять прості змінні, що містять єдиний елемент
даних, як в прикладах, наведених нижче, та крім цього вони можуть
містити більш складні структури даних - масиви і структури. Ці
структури пам'яті можуть містити набагато більше елементів, ніж
регістрів у комп'ютері. Як же тоді комп'ютер може представляти і
мати доступ до елементів таких великих структур?

Лише невелика кількість інформації може зберігатися процесором у
регістрах, та пам'ять комп'ютера містить мільярди елементів
пам'яті. Таким чином структури даних (масиви і структури)
зберігаються в пам'яті.

\textbf{data transfer instruction} (інструкція передачі даних) -
команда, що переносить інформацію між пам'яттю і регістрами.
\textbf{address A} - значення, що визначає розміщення певного
елемента в масиві пам'яті.

Як пояснювалось вище, арифметичні операції в MIPS виконуються
тільки над регістрами, таким чином MIPS має включати інструкції, що
передають інформацію з пам'яті в регістри. Такі інструкції
називаються data transfer instructions (інструкції передачі даних).
Щоб доступитися до слова в пам'яті інструкція повинна містити
адресу комірки пам'яті. Пам'ять - це просто великий одновимірний
масив з адресою, що є фактично індексом цього масиву(починаючи з
0).

Як видно, наприклад, на рисунку 2, адреса 3-го елемента даних - 2,
а значення комірки Memory[2] = 10.

FIXME

Рис. 8. Адреси комірок пам'яті та їх вміст.

Якби ці елементи були словами, то ці адреси були б не коректні, так
як MIPS використовує побайтну адресацію, де на кожне слово
виділяється 4 байти. На Рис. 8 як пам'ять послідовно адресується до
слів.

\subsubsection{Компіляція та присвоювання значень при розташуванні операнду в пам'яті.}

Нехай А - масив зі 100 слів і компілятор асоціював зі зміними g та
h регістри \$s1, \$s2. Також припустимо, що початкова адреса, або
інакше базова адреса, (адреса 1-го елемента) зберігається в \$s3.
Компіляція цього виразу присвоювання на мові С:

\begin{verbatim}
g= h + A[8];
\end{verbatim}
Інструкція передачі даних, що копіює дані з пам'яті в регістр
звичайно називається завантаженням (load). Формат інструкції
завантаження: ім'я операнда, регістр до якого він завантажується,
також константа та регістр, о використовується для доступу до
пам'яті. Адреса комірки пам'яті формується як сума константної
частини і вмісту другого регістру. Ім'я цієї команди в асемблері
MIPS - lw, що є абревіатурою load word.

Незважаючи на те, що в рядку цієї команди присвоювання лише одна
операція, один з операндів в пам'яті, отже спершу ми маємо дістати
А[8] і помістити в регістр. Адреса цього елементу масиву - це сума
базової адреси масиву А, що знаходиться в \$s3, плюс значення
індексу вибраного елемента масиву - 8. Дані мають бути поміщені в
тимчасовий регістр, для використання в наступній команді. Дивлячись
на Рисунок 2, 1-ша команда буде мати вигляд:

\begin{verbatim}
lw $t0, 8( $s3 ) #temporary reg $t0 gets A[8]
\end{verbatim}
Надалі ми трохи модифікуємо цю команду, та поки що будемо
використовувати цю спрощену версію. Дана команда може
використовувати дані, що містяться в \$t0 (що дорівнюють А[8]) поки
вона знаходяться в регістрі. Команда має додати h( що знаходиться в
$s2) до А[8]($t0) і помістити суму в регістр, що відповідає змінній
g (зв'язаній з \#s1).

\begin{verbatim}
add $s1, $s2, $t0 # g= h + A[8]
\end{verbatim}
Константа в команді передачі даних(8) називається зміщенням
(offset), а регістр, що додається для формування адреси називається
- базовим регістром (base register).

Крім асоціювання змінних з регістрами, компілятор виділяє місце в
пам'яті масивам та структурам. Компілятор може помістити потрібну
адресу початку в команду передачі даних. Більшість архітектур
адресуються до окремого байта. Отже адреса слова відповідає адресі
одного з 4-х байт всередині слова, і адреси наступних слів
відрізняються на 4. На рисунку 3 зображено фактичні адреси MIPS для
слів з рисунку 2. Адреса 3-го слова - 8.

FIXME : для слів з рисунку 2

В MIPS слова мають починатись з адрес, що кратні 4. Ця вимога
називається забороною вирівнювання (alignment restriction), вона
також присутня в багатьох архітектурах. Комп'ютери можна поділити
на ті, що читають адреси старшим розрядом, вони називаються
``big endian'', інші, читають адресу починаючи з молодшого байта -
``little endian''. MIPS відноситься до класу big-endian.

Байтна адресація також має свій вплив на індекс масиву. Щоб
отримати адресу потрібного байта у вищенаведеному коді, зміщення,
що додається до регістру \$s3 має бути 4*8 = 32, щоб ми вибрали
елемент A[8]], а не A[8/4].

\begin{figure}[htb]
\centering
\includegraphics{4_memory_bytes.png}
\caption{Index}
\end{figure}

Рис. 9. Фактична пам'ять MIPS і вміст пам'яті для цих слів.

Змінені адреси виділені, в порівнянні з Рис. 9. Так як MIPS
адресується до кожного байту, адреси слів помножені на 4: 4 байти
на слово.

Команда, що доповнює завантаження зазвичай називається збереження
(запам'ятовування), вона копіює дані з регісра в пам'ять. Формат
запам'ятовування (store) такий же як і у завантаження: ім'я
операції, регістр, який зберігаємо, далі зміщення, щоб вибрати
елемент масиву, і базовий регістр. Отже, адреса MIPS визначається
частково константою, частково вмістом регістра. В асемблері MIPS ця
команда має назву sw - store word.

\subsubsection{Компіляція з використанням Завантаження(load) і Зберіганням(store).}

Припустимо, що змінна h асоційована з регістром \$s2 і базова
адреса масиву А в регістрі \$s3. Який же тоді ми отримаємо код на
асемблері MIPS для наступної команд на С?

\begin{verbatim}
A[12] = h + A[8]
\end{verbatim}
Хоча в команді на С ми маємо 1 оперцію тепер вже 2 операнди
знаходяться в пам'яті, отже нам потрібно ще більше команд MIPS.
Перші 2 команди точно такі ж як і в попередньому прикладі, окрім
того що ми використовуємо потрібне зміщення для адресації до байту
в команді lw, щоб вибрати А[8], а команда add поміщає суму в \$10.

Load word та store word - команди, що копіюють слова з пам'яті в
регістр і навпаки. Інші архітектури використовують інші команди для
передачі даних разом із load та store ( наприклад Intel x86).

\begin{verbatim}
lw $t0, 32( $s3 ) # temporary reg $t0 gets A[8]
add $t0, $s2, $t0 # temporary reg $t0 gets h+ A[8]
\end{verbatim}
Остання команда записує суму в А[12], використовуючи 48(12*4) як
зміщення і регістр \$s3 як базову адресу:

\begin{verbatim}
sw $t0,48( $s3 ) # stores h+ A[8] back into A[12]
\end{verbatim}
Багато програм мають змінних більше ніж є регістрів у комп'ютері,
тому компілятор намагається зберігати найбільш часто вживані, а
інші зберігає у пам'яті, використовуючи завантаження і записування
для пересування змінних між регістрами і пам'яттю.

Процес записування рідко використовуваних змінних( або тих, що
знадобляться пізніше) в пам'ять називається відкачка
регістрів(spilling registers).

Принцип апаратного забезпечення, що зв'язує розмір пам'яті і її
швидкість показує, що пам'ять повинна бути повільніша, ніж
регістри, так як регістрів - менше. Це дійсно так. Доступ до даних
здійснюється швидше, якщо дані з находяться в регістрі, а не в
пам'яті.

Крім того, дані легше і зручніше використовувати, якщо вони в
регістрах. Арифметична команда MIPS може прочитати вміст 2-х
регістрів, виконати дію і записати результат. Команда передачі
даних в MIPS тільки читає або пише 1 операнд, не виконуючи дій над
ними.

Таким чином, час доступу до регістрів набагато менший і вони мають
більшу пропускну здатність. Доступ до регістрів також менш
енергозатратний в порівнянні з доступом до пам'яті. Для досягнення
максимальної продуктивності та економії енергії, компілятори
повинні використовувати регістри ефективно.

\subsection{Хід роботи:}

\begin{enumerate}[1.]
\item
  Переглянути текст варіанту завдання та приклади вхідних та вихідних
  значень регістрів та пам'яті. У випадку, якщо текстове завдання
  дозволяє декілька інтерпретацій - перевірте приклади значень для
  уточнення.
\item
  Реалізувати завдання на рівні інструкцій MIPS. Якщо сформулювати
  алгоритм вирішення задачі не рівні інструкцій не вдається, можна
  спочатку розробити його на будь-якій мові програмування високого
  рівня.
\item
  Перевірити, що вихідний код компілюється без помилок и проходить
  всі тести, які надає система. У випадку, коли деякі тести
  завершуються помилкою, краще провести аналіз детального
  повідомлення про помилку, яке повертає система при виконанні цього
  тесту, ніж аналізувати повідомлення при виконанні всіх тестів у
  пакетному режимі.
\item
  Відіслати код розв'язку на сервер, перевірити результати виконання
  коду на сервері.
\item
  Оформити протокол виконання комп'ютерного практикуму: скопіювати
  вихідний код розв'язку та машинний код розв'язку у протокол.
\end{enumerate}
\subsection{Запитання для перевірки:}

\begin{enumerate}[1.]
\item
  Яке призначення DTI?
\item
  Чи можуть арифметичні операції виконуватись над пам'яттю?
\item
  Як формується адреса комірки пам'яті? Поясність алгоритм формування
  адреси на прикладі 8( \$s3 ), де \$s3 – адреса першого елемента
  масиву.
\item
  Що означає термін «заборона вимірювання»?
\item
  Що таке відкачка регістра і для чого вона слугує?
\end{enumerate}
\subsection{Варіанти завдань:}

FIXME 1. v0 = \emph{a0+}a1-*a2. Скласти вміст двух комірок памяті
по адресам із регістрів \$a0 та \$a1, відняти від суми вміст
комірки памяті по адресі із регістра \$a2, результат записати в
\$v0.

\begin{verbatim}
  Варіанти завдань
\end{verbatim}
\begin{enumerate}[1.]
\item
  \emph{(!).}(!)
  \begin{itemize}
  \item
    Приклад 1:
  \item
    Приклад 2:
  \item
    Приклад 3:
  \end{itemize}
\item
  \emph{(!).}(!)
  \begin{itemize}
  \item
    Приклад 1:
  \item
    Приклад 2:
  \item
    Приклад 3:
  \end{itemize}
\item
  \emph{(!).}(!)
  \begin{itemize}
  \item
    Приклад 1:
  \item
    Приклад 2:
  \item
    Приклад 3:
  \end{itemize}
\item
  \emph{(!).}(!)
  \begin{itemize}
  \item
    Приклад 1:
  \item
    Приклад 2:
  \item
    Приклад 3:
  \end{itemize}
\item
  v0 = \emph{a0+}a1-*a2.Скласти вміст двух комірок памяті по адресам
  із регістрів \$a0 та \$a1, відняти від суми вміст комірки памяті по
  адресі із регістра \$a2, результат записати в \$v0.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:0x104:0x104
    \item
      \$a2:0x108:0x108
    \item
      \$v0::25
    \item
      0x100:17:17
    \item
      0x104:13:13
    \item
      0x108:5:5
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:0x104:0x104
    \item
      \$a2:0x108:0x108
    \item
      \$v0::0
    \item
      0x100:9:9
    \item
      0x104:--3:--3
    \item
      0x108:6:6
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:0x104:0x104
    \item
      \$a2:0x108:0x108
    \item
      \$v0::10
    \item
      0x100:1:1
    \item
      0x104:--5:--5
    \item
      0x108:--14:--14
    \end{itemize}
  \end{itemize}
\item
  \emph{(!).}(!)
  \begin{itemize}
  \item
    Приклад 1:
  \item
    Приклад 2:
  \item
    Приклад 3:
  \end{itemize}
\end{enumerate}
\section{Комп'ютерний практикум №3}

\textbf{Тема} Умовні оператори \textbf{Мета роботи}: Ознайомитися з
інструкціями для реалізації умовних операторів.

\subsection{Теоретичні відомості.}

Інструкції вибору. Здатність робити вибір - це та особливість, що
відрізняє комп'ютер від звичайного калькулятора. На підставі
вихідних даних і значень, створених під час обчислень виконуються
різні інструкції. Прийняття рішень широко представлені в мовах
прогармування конструкціями if, іноді з використання міток -
виразів go to. Асемблер MIPS містить 2 команди вибору, такі ж як if
та go to. Перша інструкція:

\begin{verbatim}
beq register1, register2, L1
\end{verbatim}
Ця інструкція означає йти до команди, позначеної міткою L1, якщо
значення в регістрі register1 дорівнює значення в регістрі
register2. beq - абревіатура, що означає branch if equal. Наступна
команда:

\begin{verbatim}
bne register1,register2, L1
\end{verbatim}
Це означає йти до команди, позначеної міткою L1, якщо значення в
регістрі register1 не дорівнює значенню в регістрі register2. beq -
абревіатура, що означає branch if not equal.

Ці дві команди зазвичай називають умовними переходами.

\subsubsection{Компіляція if-then-else.}

Рис. 10 - це блок-схема того, що має робити код на MIPS. Перший
вираз перевіряє на рівність, начебто ми хочемо зробити вибір як в
інструкції beq. Загалом, код буде більш ефективним, якби ми
перевіряючи протилежну умову не виконували код, що слідує після
then в конструкції if, а виконували else-частину( мітка else
описуватиметься далі). Отже ми використовуємо гілку - якщо регістри
не рівні(bne).

\begin{verbatim}
bne $s3, $s4, Else # go to Else if i ≠ j
\end{verbatim}
Наступний вираз виконує одну операцію і якщо всі опернади
знаходятьсья в регістрах, то це займає всього одну команду
асемблеру:

\begin{verbatim}
add $s0, $s1, $s2 # f= g+ h (skipped if i ≠ j )
\end{verbatim}
Тепер ми маємо піти в кінець конструкції if. Цей приклад ілюструє
інший вид розгалудження. Ця інструкція символізує, що процесор
завжди піде виконувати саме цю гілку коду. Для розрізення умовного
і безумовного переходу, в MIPS безумовний перехід називається
jump(стрибок), скорочується як j (мітка Exit описана нижче):

\begin{verbatim}
j Exit #go to Exit
\end{verbatim}
В наступному сегменті коду f,g,h,i,j - змінні. Якщо 5 змінних від f
до j відповідають п'ятьом регістрам \$s0 - \$s4, то тоді який
повний код на MIPS цієї команди на С?

Операція присвоювання в частині else знову ж таки може бути
перетворена в одну інструкцію. Ми тільки маємо додати мітку Else
цій інструкції. Ми також використовуємо мітку Exit зразу після
попередньої інструкції, що символізує завершення конструкції
if-then-else.

\begin{verbatim}
Else: sub $s0, $s1, $s2 # f= g - h (skipped if i = j )
Exit:
\end{verbatim}
\begin{figure}[htb]
\centering
\includegraphics{5_branches.png}
\caption{Index}
\end{figure}

Рис. 10. Ілюстрація можливостей у вищенаведеному виразі if. Ліва
частина відповідає частині конструкції після then(умова - істинна),
а права - частині else.

Зверніть увагу на те, що асемблер звільняє компілятор і програміста
від обчислень адрес для гілок, так само, як він це робить для
розрахунку адрес для завантаження і збереження.

Компілятор рідко сам створює розгалуження, якщо вони не прописані в
самому коді програми. Уникнення труднощів написання явних міток і
розгалуджень є однією з переваг написання програм на високорівневих
мовах програмування, і також є причиною того, що програмування на
них значно швидше.

\subsubsection{Цикли.}

Вибір важливий як у випадку двох альтернатив - у конструкціях if,
так і у ітераціях і обчисленнях, що присутні в циклах. Блоками для
обох цих випадків є ті ж самі інструкції асемблеру.

\subsubsection{Приклад}

Перевірка на рівність чи нерівність є, мабуть, одним із найбільш
розповсюджених, та іноді нам потрібно перевірити чи є деяка змінна
меншою ніж інша. Наприклад, циклу for потрібно перевіряти чи менше
нуля змінна циклу. В MIPS такі порівняння здійснюються командами,
що порівнюють 2 регістри, а третій - встановлюють в 1, якщо перший
менше другого; в іншому випадку він встановлюється в 0. В MIPS ці
команди називаються set on less than, або sit. Наприклад компілятор
MIPS використовує slt, slti, beq, bne і фіксоване значення 0(
регістр \$zero), для отримання всіх цих станів: рівність,
нерівність, менше, менше рівно, більше, більше рівно.

\begin{verbatim}
slt $t0, $s3, $s4 # $t0=1 if $s3<$s4
\end{verbatim}
Вищенаведений рядок означає, що регістр \$t0 встановлюється в 1,
якщо значення регістра \$s3 менше регістра $s4$ в іному випадку
\$t0 скидається в 0. Константні операнди часто вживаються в
командах порівняння. Set o less than (sit) та set on less than
immediate (siti) працюють з цілими числами зі знаком. Беззнакові
цілі числа порівнюються використовуючи командуset on less than
unsigned (situ) та set on less than immediate unsigned
(sltiu). Інструкції порівняння повинні мати справу як з
беззнаковими числами, так і з числами з урахуванням знаку. Іноді
бітове представлення числа починається одиницею в старшому розряді,
що означає, що воно від'ємне, тобто, очевидно менше будь-якого
додатного числа, що має 0 в старшому розряді.

З іншого боку, у беззнакових чілих чисел одиниця в старшому розряді
означає, що воно більше будь-якого числа, яке має в тому ж розряді
0. (Скоро ми зрозуміємо переваги цього подвійного значення першого
біту числа, щоб полегшити перевірку на вихід за границі масиву).

\subsection{Хід роботи:}

\begin{enumerate}[1.]
\item
  Переглянути текст варіанту завдання та приклади вхідних та вихідних
  значень регістрів та пам'яті. У випадку, якщо текстове завдання
  дозволяє декілька інтерпретацій - перевірте приклади значень для
  уточнення.
\item
  Реалізувати завдання на рівні інструкцій MIPS. Якщо сформулювати
  алгоритм вирішення задачі не рівні інструкцій не вдається, можна
  спочатку розробити його на будь-якій мові програмування високого
  рівня.
\item
  Перевірити, що вихідний код компілюється без помилок и проходить
  всі тести, які надає система. У випадку, коли деякі тести
  завершуються помилкою, краще провести аналіз детального
  повідомлення про помилку, яке повертає система при виконанні цього
  тесту, ніж аналізувати повідомлення при виконанні всіх тестів у
  пакетному режимі.
\item
  Відіслати код розв'язку на сервер, перевірити результати виконання
  коду на сервері.
\item
  Оформити протокол виконання комп'ютерного практикуму: скопіювати
  вихідний код розв'язку та машинний код розв'язку у протокол.
\end{enumerate}
\subsection{Запитання для перевірки}

\begin{enumerate}[1.]
\item
  Яке призначення інструкцій bqe, bne?
\item
  Що таке мітка і для чого вона використовується?
\item
  Які особливості команд situ, sltiu?
\end{enumerate}
\subsection{Варіанти завдань}

\begin{enumerate}[1.]
\item
  Перевірка на рівність. Присвоїти \$v0 значення 1, якщо регістри
  \$a0 та \$a1 рівні, в іншому випадку присвоїти значення 0.
\item
  Визначення відсутності спільних бітів. Виконати «логічне і»
  регістрів \$a0 та \$a1, у випадку, якщо результат рівний 0, то
  записати в \$v0 1, інакше записати 0.
\item
  Перевірка рівності комірок памяті. Встановити \$v0 в 1, якщо дані
  комірк памяті по адресам із рестрів \$a0 та \$a1 рівні, інакше
  встановити \$v0 в 0.
\item
  Додавання і перевірка на нерівність. Збільшити вміст регістра \$a0
  на 2, у випадку, якщо результат більше 0, записати в \$v0 1, інакше
  записати 0.
\item
  Віднімання та перевірка на нерівність. Зменшити вміст регістра \$a0
  на 3, в випадку, якщо результат менше 0, записати в \$v0 1, інакше
  – записати 0.

\item
  Перевірка на рівність. Присвоїти \$v0значення 1, якщо регістри \$a0
  та \$a1 рівні, в іншому випадку присвоїти значення 0.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:19:19\\
    \item
      \$a1:19:19
    \item
      \$v0::1
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:25:25
    \item
      \$a1:2:2
    \item
      \$v0::0
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:14:14
    \item
      \$a1:--14:--14
    \item
      \$v0::0
    \end{itemize}
  \end{itemize}
\item
  Визначення відсутності спільних бітів. Виконати «логічне і»
  регістрів \$a0 та \$a1, у випадку, якщо результат рівний 0, то
  записати в \$v0 1,інакше записати 0.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:12:12
    \item
      \$a1:48:48
    \item
      \$v0::1
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:10:10
    \item
      \$a1:5:5
    \item
      \$v0::1
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:11:11
    \item
      \$a1:2:2
    \item
      \$v0::0
    \end{itemize}
  \end{itemize}
\item
  Перевірка рівності комірок памяті. Встановити \$v0в 1, якщо дані
  комірк памяті по адресам із рестрів $a0 та$a1рівні, інакше
  встановити \$v0в 0.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:0x104:0x104
    \item
      \$v0::1
    \item
      0x100:25:25
    \item
      0x104:25:25
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:0x104:0x104
    \item
      \$v0::0
    \item
      0x100:0:0
    \item
      0x104:10:10
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:0x104:0x104
    \item
      \$v0::1
    \item
      0x100:117:117
    \item
      0x104:117:117
    \end{itemize}
  \end{itemize}
\item
  Додавання і перевірка на нерівність. Збільшити вміст регістра
  \$a0на 2, у випадку, якщо результат більше 0, записати в \$v0 1,
  інакше записати 0.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:5:7
    \item
      \$v0::1
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:--2:0
    \item
      \$v0::0
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:1:3
    \item
      \$v0::1
    \end{itemize}
  \end{itemize}
\item
  Віднімання та перевірка на нерівність. Зменшити вміст регістра \$a0
  на 3, в випадку, якщо результат менше 0, записати в \$v01, інакше –
  записати 0.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:2:--1
    \item
      \$v0::1
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:3:0
    \item
      \$v0::0
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:--5:--8
    \item
      \$v0::1
    \end{itemize}
  \end{itemize}
\item
  \emph{(!).}(!)
  \begin{itemize}
  \item
    Приклад 1:
  \item
    Приклад 2:
  \item
    Приклад 3:
  \end{itemize}
\end{enumerate}
\section{Комп'ютерний практикум №4}

\textbf{Тема}: Робота з масивами \textbf{Мета роботи}: Ознайомитися
з базовими засобами для роботи з масивами.

\subsection{Теоретичні відомості.}

\subsubsection{Компіляція циклу while на мові С.}

Нижче наведено стандартний цикл на С:

\begin{verbatim}
while ( save[i] == k) {
   i += 1;
 }
\end{verbatim}
Припустимо, щл i та k відповідають регістрам \$s3 та \$s5, а перший
елемент масиву (базова адреса) зберігається в регістрі \$s6. Який
же тоді ми отримаємо код на ассемблері MIPS?

Перший крок - це завантаження і збереження save[i] в тимчасовий
регістр. Але перед тим як ми це зробимо ми маємо отримати її
адресу. Перед тим як ми додамо і до базової адреси масиву для
отримання потрібної адреси, ми маємо домножити індекс на 4 (ця
особливість адресації до кожного байту описувалась раніше).
Нащастя, ми можемо використовувати логічний зсув вліво, так як зсув
на 2 біти еквівалентний сноженню на 4.

Ми маємо додати спеціяльну мітку Loop, щоб мати змогу повернутися
до тієї інструкції в кінці масиву:

\begin{verbatim}
Loop: sll $t1, $s3, 2 # temp reg $t1 = i * 4
\end{verbatim}
Для отримання адреси save[i], ми маємо додати \$t1 і базову адресу
масиву save, що знаходиться в \$s6:

\begin{verbatim}
add $t1, $t1, $s6 # $t1 = address of save[i]
\end{verbatim}
Тепер ми можемо використовувати цю адресу для завантаження save[i]
в тимчасовий регістр:

\begin{verbatim}
lw $t0, 0( $t1 ) # temp reg $t0= save[i]
\end{verbatim}
Наступна команда виконує перевірку в циклі, і виходить по мітці
Exit, якщо save[i] \textless{}\textgreater{} k:

\begin{verbatim}
bne $t0, $s5, Exit #go to Exit if save[i] ≠ k
\end{verbatim}
Наступна команда додає 1 до i:

\begin{verbatim}
addi $s3, $s3,1 # i = i+1
\end{verbatim}
В кінці циклу ми знову повертаємося до верхівки циклу - перевірки
умови while. Просто додаємо мітку виходу Exit, і маємо цикл:

\begin{verbatim}
j Loop # go to Loop
Exit:
\end{verbatim}
\subsection{Хід роботи:}

\begin{enumerate}[1.]
\item
  Переглянути текст варіанту завдання та приклади вхідних та вихідних
  значень регістрів та пам'яті. У випадку, якщо текстове завдання
  дозволяє декілька інтерпретацій - перевірте приклади значень для
  уточнення.
\item
  Реалізувати завдання на рівні інструкцій MIPS. Якщо сформулювати
  алгоритм вирішення задачі не рівні інструкцій не вдається, можна
  спочатку розробити його на будь-якій мові програмування високого
  рівня.
\item
  Перевірити, що вихідний код компілюється без помилок и проходить
  всі тести, які надає система. У випадку, коли деякі тести
  завершуються помилкою, краще провести аналіз детального
  повідомлення про помилку, яке повертає система при виконанні цього
  тесту, ніж аналізувати повідомлення при виконанні всіх тестів у
  пакетному режимі.
\item
  Відіслати код розв'язку на сервер, перевірити результати виконання
  коду на сервері.
\item
  Оформити протокол виконання комп'ютерного практикуму: скопіювати
  вихідний код розв'язку та машинний код розв'язку у протокол.
\end{enumerate}
\subsection{Запитання для перевірки:}

\begin{enumerate}[1.]
\item
  Як здійснюється рух по масиву? Які інструкції для цього
  використовуються?
\item
  Як реалізувати на рівні інструкцій MIPS цикл While?
\end{enumerate}
\subsection{Варіанти завдань:}

\begin{enumerate}[1.]
\item
  Визначення рівності. Задано цілочисельний масив. Знайти
  максимальний елемент.
\item
  Входження мінімуму масива. Задано цілочисельний масив. Підрахувати
  скільки раз в ньому зустрічається мінімальний елемент.
\item
  Розкладання числа. Число задається цілочисельним масивом.
  Реалізувати алгоритм переведення числа із системи числення з
  основою р (регістр \$a2) в безпосереднє значення.
\item
  Сума елементів з непарним індексом. Задано цілочисельний масив.
  Знайти суму елементів масива з непарним індексом. Індексування
  елементів починається з нуля.
\item
  Додатня підпослідовність. Задано цілочисельний масив. Підрахувати
  найбільшу кількість розташованих послідовно додатніх елементів.
\item
  Обернення масиву. Задано масив натуральних чисел. Змінити міцями
  перший елемент з останнім, другий – з передостаннім і т.д.

\item
  Визначення рівності. Задано цілочисельний масив. Знайти
  максимальний елемент.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:5:5
    \item
      \$v0::5
    \item
      0x100:1:1
    \item
      0x104:2:2
    \item
      0x108:3:3
    \item
      0x10C:4:4
    \item
      0x110:5:5
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:7:7
    \item
      \$v0::0
    \item
      0x100:--1:--1
    \item
      0x104:--2:--2
    \item
      0x108:--7:--7
    \item
      0x10C:0:0
    \item
      0x110:--11:--11
    \item
      0x114:--16:--16
    \item
      0x118:--9:--9
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:7:7
    \item
      \$v0::--1
    \item
      0x100:--4:--4
    \item
      0x104:--3:--3
    \item
      0x108:--7:--7
    \item
      0x10C:--12:--12
    \item
      0x110:--1:--1
    \item
      0x114:--21:--21
    \item
      0x118:--9:--9
    \end{itemize}
  \end{itemize}
\item
  Входження мінімуму масива. Задано цілочисельний масив. Підрахувати
  скільки раз в ньому зустрічається мінімальний елемент.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:5:5
    \item
      \$v0::1
    \item
      0x100:1:1
    \item
      0x104:2:2
    \item
      0x108:3:3
    \item
      0x10C:8:8
    \item
      0x110:5:5
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      \$v0::3
    \item
      0x100:--1:--1
    \item
      0x104:2:2
    \item
      0x108:3:3
    \item
      0x10C:--1:--1
    \item
      0x110:5:5
    \item
      0x114:--1:--1
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      \$v0::6
    \item
      0x100:8:8
    \item
      0x104:8:8
    \item
      0x108:8:8
    \item
      0x10C:8:8
    \item
      0x110:8:8
    \item
      0x114:8:8
    \end{itemize}
  \end{itemize}
\item
  Розкладання числа. Число задається цілочисельним масивом.
  Реалізувати алгоритм переведення числа із системи числення з
  основою р (регістр \$a2) в безпосереднє значення.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:5:5
    \item
      \$a2:3:3
    \item
      \$v0::102
    \item
      0x100:1:1
    \item
      0x104:0:0
    \item
      0x108:2:2
    \item
      0x10C:1:1
    \item
      0x110:0:0
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:5:5
    \item
      \$a2:4:4
    \item
      \$v0::708
    \item
      0x100:2:2
    \item
      0x104:3:3
    \item
      0x108:0:0
    \item
      0x10C:1:1
    \item
      0x110:0:0
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:4:4
    \item
      \$a2:10:10
    \item
      \$v0::2193
    \item
      0x100:2:2
    \item
      0x104:1:1
    \item
      0x108:9:9
    \item
      0x10C:3:3
    \end{itemize}
  \end{itemize}
\item
  Сума елементів з непарним індексом. Задано цілочисельний масив.
  Знайти суму елементів масива з непарним індексом. Індексування
  елементів починається з нуля.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:8:8
    \item
      \$v0::19
    \item
      0x100:1:1
    \item
      0x104:2:2
    \item
      0x108:3:3
    \item
      0x10C:3:3
    \item
      0x110:7:7
    \item
      0x114:5:5
    \item
      0x118:2:2
    \item
      0x11C:9:9
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      \$v0::9
    \item
      0x100:4:4
    \item
      0x104:0:0
    \item
      0x108:2:2
    \item
      0x10C:8:8
    \item
      0x110:7:7
    \item
      0x114:1:1
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:9:9
    \item
      \$v0::20
    \item
      0x100:1:1
    \item
      0x104:1:1
    \item
      0x108:5:5
    \item
      0x10C:8:8
    \item
      0x110:3:3
    \item
      0x114:2:2
    \item
      0x118:0:0
    \item
      0x11C:9:9
    \item
      0x120:7:7
    \end{itemize}
  \end{itemize}
\item
  Додатня підпослідовність. Задано цілочисельний масив. Підрахувати
  найбільшу кількість розташованих послідовно додатніх елементів.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      \$v0::2
    \item
      0x100:--1:--1
    \item
      0x104:1:1
    \item
      0x108:1:1
    \item
      0x10C:0:0
    \item
      0x110:1:1
    \item
      0x114:--1:--1
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      \$v0::4
    \item
      0x100:7:7
    \item
      0x104:1:1
    \item
      0x108:1:1
    \item
      0x10C:4:4
    \item
      0x110:--4:--4
    \item
      0x114:--18:--18
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:7:7
    \item
      \$v0::3
    \item
      0x100:0:0
    \item
      0x104:1:1
    \item
      0x108:1:1
    \item
      0x10C:--5:--5
    \item
      0x110:1:1
    \item
      0x114:2:2
    \item
      0x118:9:9
    \end{itemize}
  \end{itemize}
\item
  Обернення масиву. Задано масив натуральних чисел. Змінити міцями
  перший елемент з останнім, другий – з передостаннім і т.д.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:5:5
    \item
      0x100:5:1
    \item
      0x104:4:2
    \item
      0x108:3:3
    \item
      0x10C:2:4
    \item
      0x110:1:5
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      0x100:6:11
    \item
      0x104:2:3
    \item
      0x108:1:4
    \item
      0x10C:4:1
    \item
      0x110:3:2
    \item
      0x114:11:6
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:1:1
    \item
      0x100:5:5
    \end{itemize}
  \end{itemize}
\end{enumerate}
\section{Комп'ютерний практикум №5}

\textbf{Тема}: Функції \textbf{Мета роботи}: Ознайомитися з
базовими засобами для завдання та виклику функцій.

\subsection{Теоретичні відомості.}

\subsubsection{Вкладені процедури.}

Процедура, що не викликає інші процедури називається ліст
процедурою. Життя було б простішим, якщо б всі процедури були
такими, але це не так. На зразок шпигуна, який залучає до виконання
частини операції інших шпигунів, які в свою чергу можуть залучити
ще нових шпигунів, так і процедури можуть викликати інші процедури.
Більш того, рекурсивні процедури викликають клони самих себе.

Як при використанні регістрів ми маємо бути обережними, ще більшої
обережності потребує виклик не ліст процедури. Наприклад, нехай
головна програма викликає процедуру А зі значенням аргументу 3 і
поміщаючи значення 3 в регістр \$a0, а потім використовує jal A.
Далі нехай процедура А викликає процедуру В через jal В зі
значенням аргументу рівному 7, також розташованому в \$a0.

Доки процедура А не завершила свою роботу, виникає конфлікт
відносно використання регістра \$a0. Аналогічно, виникає конфлікт
відносно адреси, яка повертається в регістрі \$ra, що в даний
момент містить адресу для повернення процедурою В. Якщо не вжити
заходів по вирішенню цієї проблеми, вона призведе до того, що
процедура А втратить свою здатність повернутись до тієї програми,
що її викликала.

Одним з рішень може бути поміщення усіх інших регістрів, що мають
бути збереженими, в стек так само як було зроблено зі збереженими
регістрами. Викликаюча програма записує будь-який з аргументних
регістрів ($a0-$a3) чи тимчасових регістрів($t0-$t9), які будуть
потрібні після виклику. Процедура виклику записує регістр адреси
повернення $ra і всі зберігаючі регістри ($s0-\$s7), використані
при виклику.

Вказівник стеку \$sp призначений обраховувати кількість регістрів,
що знаходяться в стеку. І по поверненню регістри будуть відновлені
в пам'яті і вказівник стеку зміниться відповідно. Компіляція
рекурсивної процедури С, демонстрація приєднаної вкладеної
процедури.

Який код буде згенеровано на мові асемблера MIPS?

\begin{verbatim}
int fact ( int n ) {
  if ( n < 1 )
    return ( 1 );
  return ( n * fact( n - 1 ));
}
\end{verbatim}
Змінна параметра n відповідає вмісту регістра аргументу \$a0.
Скомпільована програма розпочинає роботу із мітки процедури,а потім
зберігає два регістри в стеку, адресу повернення і \$a0.

\begin{verbatim}
fact:
  addi $sp, $sp, -8 # adjust stack for 2 items
  sw $ra, 4( $sp ) # save the return address
  sw $a0, 0( $sp ) # save the argument n
\end{verbatim}
Перший раз, коли викликається процедура fact, sw зберігає адресу в
програмі, де було її викликано. Наступні дві інструкції
перевіряють, чи n менше1, переходячи до L1, якщо n більше 1. Якщо n
менше 1, процедура повертає 1 поміщаючи його в знаковий регістр:
додає 1 до 0 і записує суму в \$v0. Потім дістає із стеку 2
збережених значення і переходить на адресу повернення.

\begin{verbatim}
addi $v0, $zero, 1 # return 1
addi $sp, $sp, 8 # pop 2 items off stack
jr $ra # return to caller
\end{verbatim}
Перед тим, як дістати два елементи зі стеку, ми маємо завантажити
регістри \$a0 та \$ra. Оскільки коли n менше 1 \$a0 та \$ra не
змінюються, ми пропускаємо ці інструкції.

Якщо n не менше 1, до аргументу n застосовують декремент і потім
процедура fact викликається знову із аргументом, меншим на 1.

\begin{verbatim}
L1:
  addi $a0, $a0, -1 # n >= 1: argument gets ( n- 1 )
  jal fact # call fact with ( n-1 )
\end{verbatim}
Наступна інструкція описує зворотній хід процедури fact. Тепер
стара адреса повернення і старий аргумент відновлюються разом з
вказівником стека.

\begin{verbatim}
lw $a0, 0( $sp ) # return from jal: restore argument n
lw $ra, 4( $sp ) # restore the return address
addi $sp, $sp, 8 # adjust stack pointer to pop 2 items
\end{verbatim}
Далі регістр значення \$v0 отримує результат старого аргументу \$a0
і поточне значення самого \$v0. Ми припускаємо, що можинна
інструкція доступна, навіть якщо вона не виконується.

\begin{verbatim}
mul $v0, $a0, $v0 # return n * fact ( n – 1 )
\end{verbatim}
І в кінці, процедура переходить знову до адреси повернення

\begin{verbatim}
jr $ ra # return to the caller
\end{verbatim}
Змінна С як правило є місцем в збереженні і її інтерпретація
залежить як від типу так і від її класу збереження. Приклади
включають в себе числа типу integer та символи – char. С має два
класи збереження : автоматичний і статичний. Автоматичні змінні є
локальними по відношенню до процедури і знищуються,коли
відбувається вихід з процедури. Статичні змінні існують незалежно
від входу або виходу з процедури. Змінна С оголошена за межами всіх
процедур вважається статичною, так як і будь-яка змінна оголошена
безпосередньо з ключовим словом static. Інші мають тип збереження –
автоматичний. Щоб спростити доступ до статичних даних, програми
MIPS резервують окремий регістр, названий глобальним вказівником
або \$gp.

Глобальний вказівник – це регістр, зарезервований для вказівника на
статичну область. Символ 11 сумує все, що зберігається через виклик
процедури. Відзначимо, що кілька схем зберігають стек, гарантуючи
цим, що програма виклику процедури отримає назад ті дані при
розвантаженні зі стеку, що зберігаються в самому стекові. Стек над
\$sp фіксується просто через перевірку того, чи не ведеться запис
над \$sp; сам регістр \$sp фіксується програмою виклику через
додавання точно такої ж суми, яку дістали з нього, а інші регістри
зберігаються шляхом збереження їх в стеку(якщо вони
використовуються) і вивантаженням їх з нього.

\begin{figure}[htb]
\centering
\includegraphics{7_reg_types.png}
\caption{Index}
\end{figure}

Фігура 11: що зберігається, а що ні при виклику процедури. Якщо
програма залежить від регістра, вказуючого на стековий фрейм чи від
регістра глобального вказівника, то вони також зберігаються.

\subsection{Хід роботи}

\begin{enumerate}[1.]
\item
  Переглянути текст варіанту завдання та приклади вхідних та вихідних
  значень регістрів та пам'яті. У випадку, якщо текстове завдання
  дозволяє декілька інтерпретацій - перевірте приклади значень для
  уточнення.
\item
  Реалізувати завдання на рівні інструкцій MIPS. Якщо сформулювати
  алгоритм вирішення задачі не рівні інструкцій не вдається, можна
  спочатку розробити його на будь-якій мові програмування високого
  рівня.
\item
  Перевірити, що вихідний код компілюється без помилок и проходить
  всі тести, які надає система. У випадку, коли деякі тести
  завершуються помилкою, краще провести аналіз детального
  повідомлення про помилку, яке повертає система при виконанні цього
  тесту, ніж аналізувати повідомлення при виконанні всіх тестів у
  пакетному режимі.
\item
  Відіслати код розв'язку на сервер, перевірити результати виконання
  коду на сервері.
\item
  Оформити протокол виконання комп'ютерного практикуму: скопіювати
  вихідний код розв'язку та машинний код розв'язку у протокол.
\end{enumerate}
\subsection{Запитання для перевірки:}

\begin{enumerate}[1.]
\item
  Дайте визначення ліст-процедури.
\item
  Які конфлікти можуть виникати при одночасному виклику однієї і тієї
  ж процедури?
\item
  Від чого залежить інтепретація змінних?
\item
  Яке призначення вказівника стеку ( \$sp )?
\item
  Для чго слугує глобальний вказівник ( \$gp )?
\end{enumerate}
\subsection{Варіанти завдань:}

\begin{enumerate}[1.]
\item
  Розширення встановлених бітів. Встановити в 1 всі біти, які
  знаходяться поряд з хоча б одним вже встановленим в 1 в заданому
  числі. Припустимо, що крайні біти суміжні з нульовим. Спочатку
  встановлені одиничні біти не спрацьовують.
\item
  Розширення нульових бітів. Встановити всі біти в нуль, які суміжні
  одночасно з двома встановленими в нуль в заданому числі.
  Припустимо, що крайні біти суміжні з нульовим.
\item
  Число в оберненому порядку. Ціле додатнє число m записуємо в
  двійковій системі числення і розряди в цьому записі мають бути
  представлені в оберненому порядку. Знайти задане число.
\item
  Перестановка парних та непарних бітів. Поміняти місцями парні та
  непарні біти в 32-розрядному числі.
\item
  Ділення на
  2\textbf{n. Реалізувати функцію, яка повертає 1 для чисел k, що діляться на 2}n
  та 0 для всіх інших.
\item
  Старший біт. Визначити номер старшого біта додатнього числа. Біти
  номеруються з нуля.
\item
  Встановлені біти. Дано натуральне число n . Потрібно підрахувати
  кількість встановлених біт.
\item
  Слабке розширення встановлених бітів. Встановити в 1 всі біти, які
  суміжні з двома вже встановленими в 1 в заданому числі. Допускаємо,
  що крайні біти суміжні з нульовими. Спочатку встановлені всі біти в
  1 не скидати в нуль.
\item
  Обмін парних байтів з непарними. Поміняти місцями парні байти та
  непарні в 32-розрядному числі.
\end{enumerate}
\section{Комп'ютерний практикум №6}

\textbf{Тема}: Стек \textbf{Мета}: FIXME

\subsection{Теоретичні відомості.}

\subsubsection{Виділення місця для нових даних в стеку}

Найбільша складність в тому, що стек також використовується для
зберігання змінних, які є локальними для процедури, але не
містяться в регістрах, таких як місцеві масиви або структури.
Сегмент стека містить збережені регістри процедури і локальні
змінні, називається фреймом процедури або записом активації.
Рисунок 2.12 показує стан стека до, під час і після виклику
процедури.

Деякі програми MIPS використовує покажчик кадру (\$fр), щоб вказати
на перше слово в кадрі процедури. Покажчик стека може змінитися під
час процедури, і тому посилання на локальну змінну в пам'яті можуть
мати різні зміщення в залежності від того, де вони знаходяться у
процедурі, що робить процедуру важкою для розуміння. Крім того,
покажчик кадру надає стабільний базовий регістр для посилань в
процедурній локальної пам'яті. Зверніть увагу, що запис активації
з'являється з вознікнованіем стека використовуємо ми чи ні явний
покажчик кадру. Ми уникаємо, використання \$fр, уникаючи змін до
\$sр всередині процедури: в наших прикладах, стек коригується
тільки на вході і на виході процедури

\begin{figure}[htb]
\centering
\includegraphics{8_stack.png}
\caption{Index}
\end{figure}

Рис 2.12. Ілюстрація розміщення стека (а) до (b) під час і (с) –
після виклику процедури.

Покажчик кадру
($fp) вказує на перше слово кадру, часто – на регістр збереженого аргументу, а вказівник стека ($sp)
вказує на верхівку стека. Стек покликаний містити всі регістри, в
яких зберігається інформація, а також – локальні змінні. Так як
стековий покажчик може змінюватися в процесі виконання програми,
для програмістів простіше посилатися на змінні через стабільний
вказівник фрейму не дивлячись на те, що все може бути виконано
єдино за допомогою стекового покажчика і невеликий адресної
арифметики. Якщо ж там немає локальних змінних у стеці процедури,
компілятор збереже час через те, що не буде створювати і видаляти
покажчик кадру. Коли покажчик кадру використовується, він
ініциализується адресою ($sp), і потім ($sp) відновлюється з
(\$fp).

Фрейм процедури також називається записом активації. Сегмент стека,
що містить збережені регістри процедури та локальні змінні.
Вказівник фрейму - значення, що позначають розташування збережених
регістрів і локальних змінних для даної процедури

\subsubsection{Виділення місця для нових даних в купі}

\begin{figure}[htb]
\centering
\includegraphics{8_heap.png}
\caption{Index}
\end{figure}

Рисунок 2.13 Розташування пам'яті MIPS для програм і даних.

Ці адреси є просто загальні конвенції, не частина архітектури MIPS.
Стековий вказівник ініціалізується як 7fff fffc в Hex. З іншого
боку, код програми починається з 0040 0000 в Hex. Статичні дані
починаються з 1000 0000, динамічні дані, які виділяються через
malloc () в С, або через new в java, розміщені наступними.Цей
сектор зростає в область, звану купою.Глобальний покажчик (\$ gp)
використовується для більш швидкого доступу до даних. Він
ініціалізується значенням 1000 8000 в Hex, так що він може мати
доступ до всіх клітинок з адресами від 1000 0000 до 1000 ffff,
використовуючи позитивні і негативні 16-бітові зміщення з (\$gp).

На додаток до локальних змінних процедури, програмістам С потрібне
місце в оперативній пам'яті для статичних змінних і для динамічних
структур даних. Рисунок 2.13 показує конвенції MIPS для розподілу
пам'яті. Стек починається у верхньому кінці пам'яті і росте вниз.
Перша частина нижньої пам'яті зарезервована, після чого йде
машинний код MIPS, традиційно званий текстовим сегментом. Над цим
кодом статичний сегмент даних, який є місцем для констант та інших
статичних змінних. Хоча масиви, як правило, фіксованої довжини і
тому добре підходить для статичного сегмента даних, такі структури
даних як пов'язані списки, як правило, зростають або зменшуються
протягом їх життя.Сегмент для таких структур даних є традиційно
називається одним гуртом, і вона розташована наступною в пам'яті.

Зверніть увагу, що цей розподіл змушує стек і купі рости назустріч
один одному, що дозволяє ефективно використовувати пам'ять, як два
сегменти перетікають один в одного. С виділяє і звільняє місце в
купі явними функціями: malloc() виділяє місце в купі і повертає
вказівник на нього, а free () звільняє виділену пам'ять. Виділення
пам'яті знаходиться під контролем програми на С, і це є джерелом
багатьох розповсюджених і важких помилок.Відсутність звільнення
місця призводить до ``витоку пам'яті'', яка, в кінцевому підсумку,
використовує так багато пам'яті, що операційна система може дати
збій. Звільнення простору передчасно призводить до «висячим
вказівниками", вказівниками, які можуть вказати на те, що програма
ніколи не використовувала. Java використовує автоматичний розподіл
пам'яті та збір сміття щоб уникнути таких помилок.

На замітку: Що робити, якщо потрібно більше чотирьох параметрів?
MIPS конвенції припускають розміщення додаткових параметрів в стеку
трохи вище покажчика кадру. Потім процедура очікує перші чотири
параметри, які будуть в регістрах $a0...$a3 і решта - в пам'яті,
адресовані через покажчик фрейму.

\begin{figure}[htb]
\centering
\includegraphics{8_reg_uses.png}
\caption{Index}
\end{figure}

Рисунок 2.14 Конвенції MIPS щодо використання регістрів.

Регістр 1, званий \$at, зарезервований для асемблера, регістри
26--27, звані $k0-$k1, зарезервовані для операційної системи.
Текстовий сегмент - сегмент об'єктного файлу UNIX, який містить
машинний код мови для підпрограм в початковому файлі.

На замітку: Деякі рекурсивні процедури можуть бути реалізовані
ітераційно без використання рекурсії. Ітерація може значно
підвищити продуктивність за рахунок видалення перевитрати у зв'язку
з викликами процедур.Розглянемо, наприклад, процедуру, яка
використовується для накопичення суми:

\begin{verbatim}
int sum (int n, int acc) {
  if (n> 0)
    return sum (n-1, acc + n);

  return acc;
}
\end{verbatim}
Як уже згадувалося в підписі до рис 2.12.указатель фрейма зручний
тим, що всі посилання на змінні в стеку в процедурі будуть мати
однакове зміщення. Покажчик фрейму не необхідний, як би там не
було. Компілятор GNU MIPS С використовує вказівник фрейму, але
компілятор С від MIPS так не робить: він розглядає регістр 30 як ще
один регістр для збереження (\$s8).

\begin{verbatim}
  addi $a0, $ a1, -1 # віднімемо 1 від n
  j sum # перейдемо до sum

sum_exit:
  addi $v0, $a1, $zero   # повернемо значення ас
  jr $ra # повернемося до викликає
\end{verbatim}
Подивіться на самовиклик sum (3,0) процедури. Це виллється в
рекурсивний виклик sum (2,3) sum (1,5) sum (0,6), а потім 6
повернеться 4 рази, що можна спростити дуже красиво:

\begin{verbatim}
sum slti $ a0, 1 ​​ # якщо n <= 0
beq # a0, $ zero, sum_exit # йдемо до sum_exit якщо так
add # a0, a1 $, $ a0 # додаємо n до acc
\end{verbatim}
\subsection{Запитання для перевірки:}

\begin{enumerate}[1.]
\item
  Яке з наступних тверджень про С і Java в основному вірні?
  \begin{enumerate}[1.]
  \item
    С програмісти керують даними явно, у той час як вона автоматично
    керується в Java.
  \item
    С призводить до великих помилок покажчиків і витоків пам'яті, ніж
    Java.
  \end{enumerate}
\end{enumerate}
\subsection{Варіанти завдань:}

\begin{enumerate}[1.]
\item
  Найбільший спільний дільник. Знайти найбільший спільний дільник
  двох заданих чисел.
\item
  Кількість нулів. Підрахувати сумарну кількість нулів в запису числа
  N в системі числення з основою q.
\item
  Найменше спільне кратне двох чисел. Знайти найменше спільне кратне
  двох заданих чисел.
\item
  Число з ряду Фібоначі. По заданому числу n знайти число з ряду
  Фібоначі (1 1 2 3 5 8 13 21 34 55 …) Числа ряду номеруютьс з
  одиниці.
\item
  Видалення повторів. Дано цілочисельний масив. В вихідний масив
  потрібно вивести ті ж числа, видаливши всі повтори. Тобто, якщо в
  масиві зустрічаються 2 або більше однакових чисел, то потрібно
  залишити тільки перше входження. В регістр \$v0 вивести довжину
  отриманого масива.
\item
  Зсув масиву вліво. Задано цілочисельний масив. Провести циклічний
  зсув його елементів на k позицій вліво.

\item
  Найбільший спільний дільник. Знайти найбільший спільний дільник
  двох заданих чисел.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:12:12
    \item
      \$a1:18:18
    \item
      \$v0::6
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:36:36
    \item
      \$a1:54:54
    \item
      \$v0::18
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:117:117
    \item
      \$a1:1:1
    \item
      \$v0::1
    \end{itemize}
  \end{itemize}
\item
  Кількість нулів. Підрахувати сумарну кількість нулів в запису числа
  Nв системі числення з основою q.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:16:16
    \item
      \$a1:2:2
    \item
      \$v0::4
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:131:131
    \item
      \$a1:2:2
    \item
      \$v0::5
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:15:15
    \item
      \$a1:2:2
    \item
      \$v0::0
    \end{itemize}
  \end{itemize}
\item
  Найменше спільне кратне двох чисел. Знайти найменше спільне кратне
  двох заданих чисел.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:5:5
    \item
      \$a1:6:6
    \item
      \$v0::30
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:6:6
    \item
      \$a1:8:8
    \item
      \$v0::24
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:3:3
    \item
      \$a1:27:27
    \item
      \$v0::27
    \end{itemize}
  \end{itemize}
\item
  Число з ряду Фібоначі. По заданому числу nзнайти число з ряду
  Фібоначі (1 1 2 3 5 8 13 21 34 55 …) Числа ряду номеруютьс з
  одиниці.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:9:9
    \item
      \$v0::34
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:10:10
    \item
      \$v0::55
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:3:3
    \item
      \$v0::2
    \end{itemize}
  \end{itemize}
\item
  Видалення повторів. Дано цілочисельний масив. В вихідний масив
  потрібно вивести ті ж числа, видаливши всі повтори. Тобто, якщо в
  масиві зустрічаються2 або більше однакових чисел, то потрібно
  залишити тільки перше входження. В регістр \$v0вивести довжину
  отриманого масива.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:7:7
    \item
      \$a2:0x200:0x200
    \item
      \$v0::5
    \item
      0x100:1:1
    \item
      0x104:7:7
    \item
      0x108:2:2
    \item
      0x10C:1:1
    \item
      0x110:30:30
    \item
      0x114:7:7
    \item
      0x118:3:3
    \item
      0x200::1
    \item
      0x204::7
    \item
      0x208::2
    \item
      0x20C::30
    \item
      0x210::3
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      \$a2:0x200:0x200
    \item
      \$v0::3
    \item
      0x100:2:2
    \item
      0x104:3:3
    \item
      0x108:0:0
    \item
      0x10C:0:0
    \item
      0x110:0:0
    \item
      0x114:2:2
    \item
      0x200::2
    \item
      0x204::3
    \item
      0x208::0
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:6:6
    \item
      \$a2:0x200:0x200
    \item
      \$v0::1
    \item
      0x100:2:2
    \item
      0x104:2:2
    \item
      0x108:2:2
    \item
      0x10C:2:2
    \item
      0x110:2:2
    \item
      0x114:2:2
    \item
      0x200::2
    \end{itemize}
  \end{itemize}
\item
  Зсув масиву вліво. Задано цілочисельний масив. Провести циклічний
  зсув його елементів на kпозицій вліво.
  \begin{itemize}
  \item
    Приклад 1:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:5:5
    \item
      \$a2:2:2
    \item
      0x100:1:5
    \item
      0x104:3:7
    \item
      0x108:5:9
    \item
      0x10C:7:1
    \item
      0x110:9:3
    \end{itemize}
  \item
    Приклад 2:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:5:5
    \item
      \$a2:3:3
    \item
      0x100:0:6
    \item
      0x104:2:4
    \item
      0x108:--1:0
    \item
      0x10C:6:2
    \item
      0x110:4:--1
    \end{itemize}
  \item
    Приклад 3:
    \begin{itemize}
    \item
      \$a0:0x100:0x100
    \item
      \$a1:8:8
    \item
      \$a2:5:5
    \item
      0x100:3:8
    \item
      0x104:27:11
    \item
      0x108:9:13
    \item
      0x10C:0:3
    \item
      0x110:1:27
    \item
      0x114:8:9
    \item
      0x118:11:0
    \item
      0x11C:13:1
    \end{itemize}
  \end{itemize}
\end{enumerate}
\section{Література:}

FIXME

\end{document}

